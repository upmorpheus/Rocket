// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.7.6;

import "contracts/protocol/futures/RewardsFutureVault.sol";

/**
 * @title Main future abstraction contract for the stream futures
 * @notice Handles the stream future mecanisms
 * @dev Basis of all mecanisms for futures (registrations, period switch)
 */
abstract contract StreamFutureVault is RewardsFutureVault {
    using SafeMathUpgradeable for uint256;

    mapping(uint256 => uint256) internal scaledTotals;

    /**
     * @notice Start a new period
     * @dev needs corresponding permissions for sender
     */
    function startNewPeriod() public virtual override nextPeriodAvailable periodsActive nonReentrant {
        require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
        _switchPeriod();
        scaledTotals[getCurrentPeriodIndex()] = totalUnderlyingDeposited;
    }

    /**
     * @notice Deposit funds into ongoing period
     * @param _user user adress
     * @param _amount amount of funds to unlock
     * @dev part of the amount deposited will be used to buy back the yield already generated proportionally to the amount deposited
     */
    function deposit(address _user, uint256 _amount) external virtual override periodsActive depositsEnabled onlyController {
        require((_amount > 0) && (_amount <= ibt.balanceOf(_user)), "StreamFutureVault: ERR_AMOUNT");
        uint256 currentPeriodIndex = getCurrentPeriodIndex();

        _deposit(_user, _amount);
        uint256 currScaledTotals = scaledTotals[currentPeriodIndex];
        if (currScaledTotals == 0) {
            require(_amount > IBT_UNIT, "StreamFutureVault: ERR_FUTURE_INIT"); // require 1 ibt unit as first deposit to avoid maths scaling issue
            scaledTotals[currentPeriodIndex] = _amount;
        } else {
            scaledTotals[currentPeriodIndex] = currScaledTotals.add(getPTPerAmountDeposited(_amount));
        }
        emit FundsDeposited(_user, _amount);
    }

    /**
     * @notice Internal function for withdrawing funds corresponding to the pt holding of an address
     * @param _user user adress
     * @param _amount amount of funds to unlock
     * @dev handle the logic of withdraw but does not burn fyts
     */
    function _withdraw(address _user, uint256 _amount) internal virtual override {
        uint256 scaledAmountToRemove = getPTPerAmountDeposited(_amount);
        super._withdraw(_user, _amount);
        uint256 currentPeriodIndex = getCurrentPeriodIndex();
        scaledTotals[currentPeriodIndex] = scaledTotals[currentPeriodIndex].sub(scaledAmountToRemove);
    }

    function convertIBTToUnderlying(uint256 _amount) public view virtual override returns (uint256) {
        return _amount;
    }

    function convertUnderlyingtoIBT(uint256 _amount) public view virtual override returns (uint256) {
        return _amount;
    }

    /**
     * @notice Getter for the yield currently generated by one pt for the current period
     * @return the amount of yield (in IBT) generated during the current period
     */
    function getUnrealisedYieldPerPT() public view override returns (uint256) {
        uint256 underlyingDepositedInVault = totalUnderlyingDeposited;
        if (underlyingDepositedInVault == 0) return 0;
        return
            ((ibt.balanceOf(address(this)).sub(underlyingDepositedInVault)).mul(IBT_UNIT)).div(underlyingDepositedInVault);
    }

    /**
     * @notice Getter for the number of pt that can be minted for an amoumt deposited now
     * @param _amount the amount to of IBT to deposit
     * @return the number of pt that can be minted for that amount
     * @dev need to be computed before the deposit
     */
    function getPTPerAmountDeposited(uint256 _amount) public view override returns (uint256) {
        return APWineMaths.getScaledInput(_amount, scaledTotals[getCurrentPeriodIndex()], ibt.balanceOf(address(this)));
    }
}
